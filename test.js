// Generated by CoffeeScript 1.6.3
(function() {
  var ItemPile, test;

  test = require('tape');

  ItemPile = require('./');

  test('create default', function(t) {
    var a;
    a = new ItemPile('dirt');
    t.equal(a.item, 'dirt');
    t.equal(a.count, 1);
    t.deepEqual(a.tags, {});
    return t.end();
  });

  test('create illegal zero-count pile', function(t) {
    var a, caughtError, error;
    try {
      a = new ItemPile('dirt', 0);
    } catch (_error) {
      error = _error;
      caughtError = error;
    }
    console.log(caughtError);
    t.equal(caughtError !== void 0, true);
    return t.end();
  });

  test('create illegal undefined item', function(t) {
    var a, caughtError, error;
    try {
      a = new ItemPile(void 0, 0);
    } catch (_error) {
      error = _error;
      caughtError = error;
    }
    console.log(caughtError);
    t.equal(caughtError !== void 0, true);
    return t.end();
  });

  test('immutable count', function(t) {
    'use strict';
    var a, caughtError, error;
    a = new ItemPile('dirt', 1);
    t.equal(a.count, 1);
    try {
      a.count = 2;
    } catch (_error) {
      error = _error;
      caughtError = error;
    }
    console.log(caughtError);
    t.equal(caughtError !== void 0, true);
    t.equal(a.count, 1);
    return t.end();
  });

  test('immutable item', function(t) {
    'use strict';
    var a, caughtError, error;
    a = new ItemPile('sand', 1);
    try {
      a.item = 'glass';
    } catch (_error) {
      error = _error;
      caughtError = error;
    }
    console.log(caughtError);
    t.equal(caughtError !== void 0, true);
    t.equal(a.item, 'sand');
    return t.end();
  });

  test('immutable tags', function(t) {
    'use strict';
    var a, caughtError, error;
    a = new ItemPile('tool', 1, {
      damage: 0
    });
    try {
      a.tags = {
        damage: 1
      };
    } catch (_error) {
      error = _error;
      caughtError = error;
    }
    console.log(caughtError);
    t.equal(caughtError !== void 0, true);
    t.deepEqual(a.tags, {
      damage: 0
    });
    return t.end();
  });

  test('immutable tags deep', function(t) {
    'use strict';
    var a, caughtError, error;
    a = new ItemPile('tool', 1, {
      modifiers: {
        lastsLonger: 1
      }
    });
    try {
      a.tags.modifiers.lastsLonger = 2;
    } catch (_error) {
      error = _error;
      caughtError = error;
    }
    t.equal(caughtError !== void 0, true);
    console.log(caughtError);
    t.deepEqual(a.tags, {
      modifiers: {
        lastsLonger: 1
      }
    });
    return t.end();
  });

  test('empty tags', function(t) {
    var a;
    a = new ItemPile('dirt', 1, {});
    t.deepEqual(a.tags, {});
    return t.end();
  });

  test('increased', function(t) {
    var a, a2, a3, excess, _ref, _ref1;
    a = new ItemPile('dirt', 1);
    _ref = a.increased(10), a2 = _ref[0], excess = _ref[1];
    t.equal(a2.count, 11);
    t.equal(excess, 0);
    _ref1 = a2.increased(100), a3 = _ref1[0], excess = _ref1[1];
    t.equal(a3.count, 64);
    t.equal(excess, 47);
    return t.end();
  });

  test('merge simple', function(t) {
    var a, a2, b, b2, _ref;
    a = new ItemPile('dirt', 10);
    b = new ItemPile('dirt', 20);
    _ref = a.mergedPile(b), a2 = _ref[0], b2 = _ref[1];
    t.equal(a2.item, a.item);
    t.equal(a2.count, 30);
    t.equal(b2 === void 0, true);
    return t.end();
  });

  test('merge big', function(t) {
    var a, a2, b, b2, _ref;
    a = new ItemPile('dirt', 1);
    b = new ItemPile('dirt', 80);
    _ref = a.mergedPile(b), a2 = _ref[0], b2 = _ref[1];
    t.equal(a2.item, b2.item);
    t.equal(a2.count + b2.count, 80 + 1);
    t.equal(a2.count, 64);
    t.equal(b2.count, 17);
    return t.end();
  });

  test('split', function(t) {
    var a, a2, b, _ref;
    a = new ItemPile('dirt', 64);
    _ref = a.splitPile(16), a2 = _ref[0], b = _ref[1];
    t.equal(a2.count, 48);
    t.equal(b.count, 16);
    t.equal(a2.item, b.item);
    t.equal(a2.tags, b.tags);
    return t.end();
  });

  test('split all', function(t) {
    var a, a2, b, _ref;
    a = new ItemPile('dirt', 10);
    _ref = a.splitPile(10), a2 = _ref[0], b = _ref[1];
    t.equal(a2 === void 0, true);
    t.equal(b.item, a.item);
    t.equal(b.count, 10);
    t.equal(b.count, a.count);
    return t.end();
  });

  test('split bad', function(t) {
    var a, a2, b, _ref;
    a = new ItemPile('dirt', 10);
    _ref = a.splitPile(1000), a2 = _ref[0], b = _ref[1];
    t.equal(b === void 0, true);
    t.equal(a2.count, a.count);
    return t.end();
  });

  test('split neg', function(t) {
    var a, a2, b, _ref;
    a = new ItemPile('dirt', 10);
    _ref = a.splitPile(-1), a2 = _ref[0], b = _ref[1];
    t.equal(a2.count, 1);
    t.equal(b.count, 9);
    return t.end();
  });

  test('split fract half', function(t) {
    var a, a2, b, _ref;
    a = new ItemPile('gold', 10);
    _ref = a.splitPile(0.5), a2 = _ref[0], b = _ref[1];
    t.equal(a2.count, 5);
    t.equal(b.count, 5);
    return t.end();
  });

  test('split fract uneven', function(t) {
    var a, a2, b, _ref;
    a = new ItemPile('gold', 11);
    _ref = a.splitPile(0.5), a2 = _ref[0], b = _ref[1];
    t.equal(a2.count, 5);
    t.equal(b.count, 6);
    return t.end();
  });

  test('matches', function(t) {
    var a, b, c, d, e, f, g;
    a = new ItemPile('dirt', 3);
    b = new ItemPile('dirt', 4);
    t.equal(a.matchesType(b), true);
    t.equal(a.matchesTypeAndCount(b), false);
    t.equal(a.matchesAll(b), false);
    c = new ItemPile('dirt', 4);
    t.equal(b.matchesType(c), true);
    t.equal(b.matchesTypeAndCount(c), true);
    t.equal(b.matchesAll(c), true);
    t.equal(c.matchesType(b), true);
    t.equal(c.matchesTypeAndCount(b), true);
    t.equal(c.matchesAll(b), true);
    d = new ItemPile('magic', 1, {
      foo: -7
    });
    e = new ItemPile('magic', 1, {
      foo: 54
    });
    f = new ItemPile('magic', 1, {
      foo: -7
    });
    g = new ItemPile('magic', 2, {
      foo: -7
    });
    t.equal(d.matchesType(d), true);
    t.equal(d.matchesTypeAndCount(e), true);
    t.equal(d.matchesAll(e), false);
    t.equal(d.matchesAll(f), true);
    t.equal(g.matchesTypeAndTags(d), true);
    return t.end();
  });

  test('toString', function(t) {
    var a, b;
    a = new ItemPile('dirt', 42);
    console.log(a.toString());
    t.equal(a + '', '42:dirt');
    b = new ItemPile('magic', 1, {
      foo: -7
    });
    console.log(b.toString());
    t.equal(b + '', '1:magic {"foo":-7}');
    return t.end();
  });

  test('fromString', function(t) {
    var a;
    a = ItemPile.fromString('24:dirt');
    console.log(a);
    t.equal(a.count, 24);
    t.equal(a.item, 'dirt');
    t.equal(a.hasTags(), false);
    return t.end();
  });

  test('fromString/toString roundtrip', function(t) {
    var b, outStr, s, strings, _i, _len;
    strings = ['24:dirt', '48:dirt', '1000:dirt', '1:foo {"tag":1}', '2:hmm {"foo":[],"bar":2}'];
    for (_i = 0, _len = strings.length; _i < _len; _i++) {
      s = strings[_i];
      b = ItemPile.fromString(s);
      outStr = b + '';
      t.equal(s, outStr);
      console.log("=", s, outStr);
    }
    return t.end();
  });

  test('itemFromString', function(t) {
    var a, b, c, d;
    a = ItemPile.itemFromString('foo');
    t.equals(a, 'foo');
    b = ItemPile.itemFromString(void 0);
    t.equal(b === void 0, true);
    c = ItemPile.itemToString('bar');
    t.equals(c, 'bar');
    d = ItemPile.itemToString(ItemPile.itemFromString(null));
    t.equals(d, 'undefined');
    return t.end();
  });

  test('infinite', function(t) {
    var a, a2, a3, a4, excessCount, removedCount, _ref, _ref1, _ref2;
    a = new ItemPile('magic', Infinity);
    _ref = a.decreased(1), a2 = _ref[0], removedCount = _ref[1];
    t.equal(a2.count, Infinity);
    _ref1 = a.decreased(1000000), a3 = _ref1[0], removedCount = _ref1[1];
    t.equal(a3.count, Infinity);
    _ref2 = a.increased(1000000000), a4 = _ref2[0], excessCount = _ref2[1];
    t.equal(a4.count, Infinity);
    return t.end();
  });

}).call(this);
